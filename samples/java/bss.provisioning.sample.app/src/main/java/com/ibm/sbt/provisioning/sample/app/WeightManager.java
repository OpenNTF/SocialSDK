/*
 * Â© Copyright IBM Corp. 2014
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.ibm.sbt.provisioning.sample.app;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

import com.ibm.commons.util.io.json.JsonException;
import com.ibm.commons.util.io.json.JsonJavaArray;
import com.ibm.commons.util.io.json.JsonJavaObject;
import com.ibm.sbt.provisioning.sample.app.task.BSSProvisioning;
import com.ibm.sbt.provisioning.sample.app.util.BSSEndpoints;
import com.ibm.sbt.services.client.base.datahandlers.JsonDataHandler;

/**
 * This class represents a singleton responsible for managing the current weight associated with the organization .
 * */
public class WeightManager {

	private static final Logger logger = Logger.getLogger(WeightManager.class.getName());
	
	private static WeightManager instance = null;
	/**
	 * An int keeping track of the load generated by a customer towards the BSS API 
	 * while provisioning its subscribers
	 * */
	private int currentWeight = 0 ;
	/**
	 * A boolean that evaluates to true when the load {@link #threshold} for the customer in input has been reached 
	 * */
	private boolean thresholdReached ;
	/**
	 * The amount of time in millisecond that separates each {@link #currentWeight} reset operation
	 * */
	private long resetDuration ;
	private long maxSystemWeight ;
	/**
	 *  An int representing the load threshold for a customer
	 * */
	private long threshold ;
	/**
	 * <code>Map</code> keeping track of the weight associated with each call to the BSS API
	 * */
	private Map<String, Integer> weightPerBSSCall ;
	/**
	 * <code>Map</code> keeping track of the number of times a BSS endpoint is hit using the same HTTP method
	 * */
	private Map<String, Integer> counterPerBSSCall ;
	/**
	 * <code>Executor</code> needed for periodically reset the {@link #currentWeight}
	 * */
	private ScheduledExecutorService resetterExec ;
	/**
	 * <code>Executor</code> needed for periodically submit he {@link com.ibm.sbt.provisioning.sample.app.task.SubscriberTask} 
	 * instances to the provisioning  threadpool ( {@link com.ibm.sbt.provisioning.sample.app.task.BSSProvisioning#getThreadPool()} ) .
	 * */
	private ScheduledExecutorService bssProvExec ;
	
	public static synchronized WeightManager getInstance() {
        if (instance == null) 
        	instance = new WeightManager(BSSProvisioning.getWeightsFile());
        return instance;
    }
	/**
	 * Constructor responsible for the {@link #resetterExec} and {@link #bssProvExec} <code>Executor</code>(s)
	 * initialization, for the weights json input file parsing and loading of its content in the {@link #weightPerBSSCall}
	 * <code>Map</code>, and initialization of the {@link #resetDuration}, {@link #maxSystemWeight} and
	 * {@link #threshold} fields
	 * */
	public WeightManager( String settingsFilePath ){
		this.resetterExec = Executors.newSingleThreadScheduledExecutor();
		this.bssProvExec = Executors.newSingleThreadScheduledExecutor();
		
		this.weightPerBSSCall = this.getweightPerBSSCall(settingsFilePath);
		this.counterPerBSSCall = new HashMap<String, Integer>();
		for( String key : this.weightPerBSSCall.keySet() ){
			this.counterPerBSSCall.put( key , 0 ) ;
		}
		// number of seconds needed for scheduling the BSSProvisioning.getSubscribersTasks() queue +
		// ( approximate time for the initial customer and subscription creation and activation + 30sec )
		long firstBSSProvisioningIt = (((long)BSSProvisioning.getSubscribersQuantity())/4L)*1000L + 60000L ;
		this.resetterExec.scheduleAtFixedRate( new Resetter(), this.resetDuration , this.resetDuration, TimeUnit.MILLISECONDS );
		this.bssProvExec.scheduleAtFixedRate( new BSSProvisioning(), firstBSSProvisioningIt , 30000L, TimeUnit.MILLISECONDS );
		
	}
	
	/**
	 * This class represents a task that will periodically executed every
	 * {@link #resetDuration} millisecond and when executed it will reset the {@link #currentWeight}
	 * */
	class Resetter implements Runnable {
		/**
		 * Business logic of the task
		 * <p>
		 * It will simply call the {@link #resetCurrentWeight} method
		 * */
		@Override
		public void run(){
			Thread.currentThread().setName("Resetter");
			logger.finest("Resetting current weight...");
			WeightManager.this.resetCurrentWeight();
		}
	}
	/**
	 * This <code>synchronized</code> method simply reset the {@link #currentWeight} and 
	 * set the {@link #thresholdReached} value to <code>false</code>
	 * */
	private synchronized void resetCurrentWeight(){
		this.currentWeight = 0 ;
		WeightManager.this.thresholdReached = false ;
	}
	
	/**
	 * This method will update the {@link #currentWeight} associated with the organization depending on the call being made. 
	 * <p>
	 * @param  key   a String identifying the call being made<br>
	 * @return <code>true</code> if the call is permitted because the {@link #threshold} has not been reached after the {@link #currentWeight} update , 
	 * <code>false</code> otherwise
	 */
	public synchronized boolean updateCurrentWeight( String key ){
		boolean callPermitted = true ;
		if( !thresholdReached ){
			logger.finest("currentWeight = " + this.currentWeight);
			this.currentWeight = this.currentWeight + weightPerBSSCall.get(key) ;
			logger.finest("currentWeight updated = " + this.currentWeight);
			if( currentWeight >= threshold ){
				callPermitted = false ;
				logger.warning("THRESHOLD REACHED OR EXCEEDED !!!");
				this.thresholdReached = true ;
			}else{
				this.counterPerBSSCall.put( key , this.counterPerBSSCall.get(key) + 1 ) ;
			}
		}else{
			callPermitted = false ;
		}
		return callPermitted ;
	}
	/**
	 * {@link #resetDuration} getter method
	 */
	public long getResetDuration() {
		return resetDuration;
	}
	/**
	 * {@link #maxSystemWeight} getter method
	 */
	public long getMaxSystemWeight() {
		return maxSystemWeight;
	}
	/**
	 * {@link #threshold} getter method
	 */
	public long getThreshold() {
		return threshold;
	}
	/**
	 * {@link #thresholdReached} getter method
	 */
	public synchronized boolean isThresholdReached() {
		return thresholdReached;
	}
	
	public void shutdown(){
		this.resetterExec.shutdownNow();
		this.bssProvExec.shutdownNow();
		BSSProvisioning.getThreadPool().shutdown();
	}
	
	/**
	 * This method is responsible for parsing the application input file
	 * specifying the weight of each call to the BSS API .
	 * <p>
	 * @param  weightsFilePath   weights json file path<br>
	 * @return a <code>Map</code> keeping track of the weight associated with each call to the BSS API
	 */
	private Map<String, Integer> getweightPerBSSCall( String weightsFilePath ){
		String weightsJson = null ;
		Map<String, Integer> weightPerBSSCall = null ;
		JsonDataHandler handler = null ;
		try{
			weightsJson = com.ibm.sbt.provisioning.sample.app.util.Util.readFully(weightsFilePath);
			handler = new JsonDataHandler(weightsJson);
		}catch( IOException ioe ){
			System.out.println(ioe.getMessage());
		}catch (JsonException e) {
			System.out.println(e.getMessage());
		}
		if( weightsJson != null && handler != null ) {
			weightPerBSSCall = new HashMap<String, Integer>();
			long resetDuration = handler.getAsLong("settings/resetDuration");
			long maxSystemWeight = handler.getAsLong("settings/maxSystemWeight");
			long threshold = handler.getAsLong("default/limit");
			this.maxSystemWeight = maxSystemWeight ;
			this.resetDuration = resetDuration ;
			this.threshold = threshold ;
			
			JsonJavaObject defaultObj = (JsonJavaObject)handler.getAsObject("default");
			for( BSSEndpoints endpoint : BSSEndpoints.values() ){
				if(endpoint.getEndpointString().equals("/") ||
						endpoint.getEndpointString().equals("/service/authentication") || 
						endpoint.getEndpointString().equals("/service/authentication/changepassword") ||
						endpoint.getEndpointString().equals("/service/authentication/getrolelist") ){
					JsonJavaArray jsonArray = defaultObj.getAsArray(endpoint.getEndpointString());
					JsonJavaObject weightArr = (JsonJavaObject)jsonArray.get(0);
					String callWeight = weightArr.getString("weight");
					weightPerBSSCall.put(endpoint.getEndpointString(), Integer.parseInt(callWeight.replace(".0", "")) );
				}else{
					JsonJavaArray resourceCustomer = defaultObj.getAsArray(endpoint.getEndpointString());
					for( int i = 0 ; i < resourceCustomer.length() ; i++){
						JsonJavaObject entry = (JsonJavaObject)resourceCustomer.get(i);
						String callWeight = entry.getString("weight");
						String method = entry.getString("method");
						weightPerBSSCall.put(endpoint.getEndpointString()+":" + method, Integer.parseInt(callWeight.replace(".0", "")) );
					}
				}
			}
			logger.finest("latest weights settings :");
			for(String key : weightPerBSSCall.keySet()){
				logger.finest(key+"="+weightPerBSSCall.get(key));
			}
		}
		return weightPerBSSCall ; 
	}
	/**
	 * {@link #weightPerBSSCall} getter method
	 */
	public Map<String, Integer> getWeightPerBSSCall() {
		return weightPerBSSCall;
	}
	/**
	 * {@link #counterPerBSSCall} getter method
	 */
	public Map<String, Integer> getCounterPerBSSCall() {
		return counterPerBSSCall;
	}
}
